covariateData <- covs[,-which(names(covariateData) %in% removed2)]
#Overwrite NaNs with NAs:
covariateData <- replace(covariateData, is.na(covariateData), NA)
#covariateData$site <- covariateData$Site
covariateData$site <- as.character(covariateData$site)
et <- merge(et, covariateData, by = 'site', all.x=T, sort = F )
# get bps out of et
bp <- unique(et[,c('site','year','springBP','summerBP','fallBP')]  )
bp <- bp[is.finite(bp$springBP) | is.finite(bp$summerBP) | is.finite(bp$fallBP),]
bp$site <- as.character(bp$site) #for merging
siteData <- merge( x = bp, y = covariateData, by = 'site', all.x=T )
siteData$site <- siteData$Site
# turn Inf to NA in bps
siteData[!is.finite(siteData$springBP),'springBP'] <- NA
siteData[!is.finite(siteData$summerBP),'summerBP'] <- NA
siteData[!is.finite(siteData$fallBP),'fallBP'] <- NA
# merge in count of days
obsBySiteYear <- ddply(et, .(site,year), summarize,count=length(!is.na(temp)))
siteData <- merge(x=siteData, y=obsBySiteYear, all.x=T)
head(bp)
head(covariateData)
et <- et[order(et$count),] # just to make sure et is ordered for the slide function
et <- slide(et, Var = "airTemp", GroupVar = "site", slideBy = -1, NewVar='airTempLagged1')
et <- slide(et, Var = "airTemp", GroupVar = "site", slideBy = -2, NewVar='airTempLagged2')
#don't use "scale" because it creates a data type with attributes that make is difficult to use predict
et$daylS <- (et$dayl-mean(et$dayl,na.rm=T))/sd(et$dayl,na.rm=T)#scale(et$dayl)
et$sradS <- (et$srad-mean(et$srad,na.rm=T))/sd(et$srad,na.rm=T)#scale(et$srad)
et$sweS <-   (et$swe-mean(et$swe,na.rm=T))/sd(et$swe,na.rm=T)#scale(et$swe)
#pairs(~Latitude+Longitude+Forest+ Impervious+ Agriculture+ BasinElevationM+ ReachSlopePCNT+ TotDASqKM+ WetlandOrWater+ SurficialCoarseC,data=et)
#Latitude, Longitude, Forest, Impervious, Agriculture, BasinElevationM, ReachSlopePCT, TotDASqKM, WetlandOrWater, SurficialCoarseC
#Makes barcode looking plot of data records:
#-------------------------------------------
gTile <-
ggplot(siteData,aes(site.x,year,z=any(c(!is.na(springBP),!is.na(summerBP),!is.na(fallBP)))))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme_bw(base_size=20) +
theme(axis.text.x = element_blank())+
geom_tile()
#ggsave( file=paste(basedir, 'data/temperature/fromKyle/gTile', DataSource, '.png',sep=''), plot=gTile, dpi=dpiIn , width=8,height=5, units='in' )
ggsave( file=paste(basedir, 'data/temperature/fromKyle/gTile', IndexSource, '.png',sep=''), plot=gTile, dpi=dpiIn , width=8,height=5, units='in' )
#Colors by number of observations?
#---------------------------------
gTileHeat <-
ggplot(siteData,aes(site.x,year,z=count))+
geom_tile(aes(fill=count))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme(axis.text.x = element_blank())
#ggsave( file=paste(basedir, 'data/temperature/fromKyle/gTileHeat', DataSource, '.png',sep=''), plot=gTileHeat, dpi=dpiIn , width=8,height=5, units='in' )
ggsave( file=paste(graphsDir, ,'/gTileHeat', IndexSource, '.png',sep=''), plot=gTileHeat, dpi=dpiIn , width=8,height=5, units='in' )
#pairs(~Latitude+Longitude+Forest+ Impervious+ Agriculture+ BasinElevationM+ ReachSlopePCNT+ TotDASqKM+ WetlandOrWater+ SurficialCoarseC,data=et)
#Latitude, Longitude, Forest, Impervious, Agriculture, BasinElevationM, ReachSlopePCT, TotDASqKM, WetlandOrWater, SurficialCoarseC
#Makes barcode looking plot of data records:
#-------------------------------------------
gTile <-
ggplot(siteData,aes(site.x,year,z=any(c(!is.na(springBP),!is.na(summerBP),!is.na(fallBP)))))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme_bw(base_size=20) +
theme(axis.text.x = element_blank())+
geom_tile()
ggsave( file=paste0(graphsDir, sourceList, '/gTile', sourceList, '.png'), plot=gTile, dpi=dpiIn , width=8,height=5, units='in' )
#Colors by number of observations?
#---------------------------------
gTileHeat <-
ggplot(siteData,aes(site.x,year,z=count))+
geom_tile(aes(fill=count))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme(axis.text.x = element_blank())
ggsave( file=paste0(graphsDir, sourceList,'/gTileHeat', sourceList, '.png'), plot=gTileHeat, dpi=dpiIn , width=8,height=5, units='in' )
head(siteData)
#pairs(~Latitude+Longitude+Forest+ Impervious+ Agriculture+ BasinElevationM+ ReachSlopePCNT+ TotDASqKM+ WetlandOrWater+ SurficialCoarseC,data=et)
#Latitude, Longitude, Forest, Impervious, Agriculture, BasinElevationM, ReachSlopePCT, TotDASqKM, WetlandOrWater, SurficialCoarseC
#Makes barcode looking plot of data records:
#-------------------------------------------
gTile <-
ggplot(siteData,aes(site,year,z=any(c(!is.na(springBP),!is.na(summerBP),!is.na(fallBP)))))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme_bw(base_size=20) +
theme(axis.text.x = element_blank())+
geom_tile()
ggsave( file=paste0(graphsDir, sourceList, '/gTile', sourceList, '.png'), plot=gTile, dpi=dpiIn , width=8,height=5, units='in' )
#Colors by number of observations?
#---------------------------------
gTileHeat <-
ggplot(siteData,aes(site,year,z=count))+
geom_tile(aes(fill=count))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme(axis.text.x = element_blank())
ggsave( file=paste0(graphsDir, sourceList,'/gTileHeat', sourceList, '.png'), plot=gTileHeat, dpi=dpiIn , width=8,height=5, units='in' )
# could use in formulae
#fixCov <- c("Latitude","Longitude","Forest", "Agriculture","BasinElevationM","ReachSlopePCNT", "TotDASqKM", "WetlandOrWater","SurficialCoarseC")
fixCov <- c("Latitude","Longitude","Forest", "Agriculture","BasinElevationM","ReachSlopePCNT", "TotDASqKM", "WetlandOrWater","SurficialCoarseC", "ImpoundmentsOpenSqKM", "WetlandsOpenSqKM")
et2 <- et[et$segment %in% 2,]
et3 <- et[et$segment %in% 3,]
cor(et3[,fixCov])
# Segment 2:
#===========
m0S2 <- lm(temp~airTemp+airTempLagged1+airTempLagged2,
data=et2)
m1S2 <- lm(temp~airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
daylS + sradS + sweS,
data=et2)
m2S2 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
daylS + sradS + sweS)^2,
data=et2)
m3S2 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
TNC_DamCount + ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
daylS + sradS + sweS)^2,
data=et2)
AIC(m0S2,m1S2,m2S2,m3S2)
# Segment 3:
#===========
m0S3 <- lm(temp~airTemp+airTempLagged1+airTempLagged2,
data=et3)
m1S3 <- lm(temp~airTemp+airTempLagged1+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
daylS + sradS + sweS,
data=et3)
m2S3 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
daylS + sradS + sweS)^2,
data=et3)
m3S3 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
TNC_DamCount + ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
daylS + sradS + sweS)^2,
data=et3)
AIC(m0S3,m1S3,m2S3,m3S3)
#r3 <- boot.relimp(m2S3)
paste0(dataOutDir, sourceList,'/siteDataWBPs_', IndexSource, '.RData')
#```{r map data}
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
rm(list=ls())
library(ggplot2)
library(relaimpo)
library(lme4)
library(DataCombine) # for the slide function
library(plyr)
library(reshape)
library(ggmap)
library(foreign)
library(maptools)
baseDir <- 'C:/KPONEIL/'
dataInDir <- paste0(baseDir, 'GitHub/projects/temperatureProject/dataIn/')
dataOutDir <- paste0(baseDir, 'GitHub/projects/temperatureProject/dataOut/')
graphsDir <- paste0(baseDir, 'GitHub/projects/temperatureProject/graphs/')
CTDEP  <- F
MAFW   <- F
MAUSGS <- T
NHFG   <- F
NHDES  <- F
MEDMR  <- F
MTUSGSYellowstone <- F
MTUSGSGlacier <- F
sourceChoice <- list( CTDEP,   MAFW,   MAUSGS,   NHFG,   NHDES,   MEDMR,   MTUSGSYellowstone, MTUSGSGlacier)
sourceNames  <- c   ('CTDEP', 'MAFW', 'MAUSGS', 'NHFG', 'NHDES', 'MEDMR', 'MTUSGSYellowstone', 'MTUSGSGlacier')
dataSource <- sourceNames[sourceChoice == T]
sourceList <- paste0(paste0(dataSource, collapse = '_'))#, '_', Sys.Date())
dpiIn <- 400
# run temperatureSegmentedBreakPointAnalysis.Rmd before running this script
load(paste0(dataOutDir, sourceList,  '/et_', sourceList, '.RData'))
#Merge in daymet climate data:
load(paste0(dataInDir, dataSource[i], '/streamTempSitesObservedClimateData_', dataSource[i], '.RData'))
removed1 <- c('AgencyID', 'agency', 'temp', 'airTemp', 'Latitude', 'Longitude')
masterData <- masterData[, -which(names(masterData) %in% removed1)]
et <- merge(et, masterData, by = c('site', 'year', 'dOY'), all.x=T, sort = F )
et$flow <- NA
et$tAirMin <- et$tmin; et$tAirMax <- et$tmax
#Load in covariate data to merge into slopes df [no day data]
for ( i in 1:length(dataSource)){
load(paste0(dataInDir, dataSource[i], '/covariateData_', dataSource[i], '.RData')) #Jan 2014 covariateData [fixed over time]
if ( i == 1) {covs <- covariateData} else (covs <- rbind(covs, covariateData))
}
removed2 <- c('Latitude', 'Longitude')
covariateData <- covs[,-which(names(covariateData) %in% removed2)]
#Overwrite NaNs with NAs:
covariateData <- replace(covariateData, is.na(covariateData), NA)
#covariateData$site <- covariateData$Site
covariateData$site <- as.character(covariateData$site)
et <- merge(et, covariateData, by = 'site', all.x=T, sort = F )
# get bps out of et
bp <- unique(et[,c('site','year','springBP','summerBP','fallBP')]  )
bp <- bp[is.finite(bp$springBP) | is.finite(bp$summerBP) | is.finite(bp$fallBP),]
bp$site <- as.character(bp$site) #for merging
siteData <- merge( x = bp, y = covariateData, by = 'site', all.x=T )
siteData$site <- siteData$Site
# turn Inf to NA in bps
siteData[!is.finite(siteData$springBP),'springBP'] <- NA
siteData[!is.finite(siteData$summerBP),'summerBP'] <- NA
siteData[!is.finite(siteData$fallBP),'fallBP'] <- NA
# merge in count of days
obsBySiteYear <- ddply(et, .(site,year), summarize,count=length(!is.na(temp)))
siteData <- merge(x=siteData, y=obsBySiteYear, all.x=T)
et <- et[order(et$count),] # just to make sure et is ordered for the slide function
et <- slide(et, Var = "airTemp", GroupVar = "site", slideBy = -1, NewVar='airTempLagged1')
et <- slide(et, Var = "airTemp", GroupVar = "site", slideBy = -2, NewVar='airTempLagged2')
#don't use "scale" because it creates a data type with attributes that make is difficult to use predict
et$daylS <- (et$dayl-mean(et$dayl,na.rm=T))/sd(et$dayl,na.rm=T)#scale(et$dayl)
et$sradS <- (et$srad-mean(et$srad,na.rm=T))/sd(et$srad,na.rm=T)#scale(et$srad)
et$sweS <-   (et$swe-mean(et$swe,na.rm=T))/sd(et$swe,na.rm=T)#scale(et$swe)
head(et)
dataSource
# run temperatureSegmentedBreakPointAnalysis.Rmd before running this script
load(paste0(dataOutDir, sourceList,  '/et_', sourceList, '.RData'))
#Merge in daymet climate data:
load(paste0(dataInDir, dataSource, '/streamTempSitesObservedClimateData_', dataSource, '.RData'))
removed1 <- c('AgencyID', 'agency', 'temp', 'airTemp', 'Latitude', 'Longitude')
masterData <- masterData[, -which(names(masterData) %in% removed1)]
et <- merge(et, masterData, by = c('site', 'year', 'dOY'), all.x=T, sort = F )
et$flow <- NA
et$tAirMin <- et$tmin; et$tAirMax <- et$tmax
#Load in covariate data to merge into slopes df [no day data]
for ( i in 1:length(dataSource)){
load(paste0(dataInDir, dataSource[i], '/covariateData_', dataSource[i], '.RData')) #Jan 2014 covariateData [fixed over time]
if ( i == 1) {covs <- covariateData} else (covs <- rbind(covs, covariateData))
}
removed2 <- c('Latitude', 'Longitude')
covariateData <- covs[,-which(names(covariateData) %in% removed2)]
#Overwrite NaNs with NAs:
covariateData <- replace(covariateData, is.na(covariateData), NA)
#covariateData$site <- covariateData$Site
covariateData$site <- as.character(covariateData$site)
et <- merge(et, covariateData, by = 'site', all.x=T, sort = F )
# get bps out of et
bp <- unique(et[,c('site','year','springBP','summerBP','fallBP')]  )
bp <- bp[is.finite(bp$springBP) | is.finite(bp$summerBP) | is.finite(bp$fallBP),]
bp$site <- as.character(bp$site) #for merging
siteData <- merge( x = bp, y = covariateData, by = 'site', all.x=T )
siteData$site <- siteData$Site
# turn Inf to NA in bps
siteData[!is.finite(siteData$springBP),'springBP'] <- NA
siteData[!is.finite(siteData$summerBP),'summerBP'] <- NA
siteData[!is.finite(siteData$fallBP),'fallBP'] <- NA
# merge in count of days
obsBySiteYear <- ddply(et, .(site,year), summarize,count=length(!is.na(temp)))
siteData <- merge(x=siteData, y=obsBySiteYear, all.x=T)
et <- et[order(et$count),] # just to make sure et is ordered for the slide function
et <- slide(et, Var = "airTemp", GroupVar = "site", slideBy = -1, NewVar='airTempLagged1')
et <- slide(et, Var = "airTemp", GroupVar = "site", slideBy = -2, NewVar='airTempLagged2')
#don't use "scale" because it creates a data type with attributes that make is difficult to use predict
et$daylS <- (et$dayl-mean(et$dayl,na.rm=T))/sd(et$dayl,na.rm=T)#scale(et$dayl)
et$sradS <- (et$srad-mean(et$srad,na.rm=T))/sd(et$srad,na.rm=T)#scale(et$srad)
et$sweS <-   (et$swe-mean(et$swe,na.rm=T))/sd(et$swe,na.rm=T)#scale(et$swe)
#pairs(~Latitude+Longitude+Forest+ Impervious+ Agriculture+ BasinElevationM+ ReachSlopePCNT+ TotDASqKM+ WetlandOrWater+ SurficialCoarseC,data=et)
#Latitude, Longitude, Forest, Impervious, Agriculture, BasinElevationM, ReachSlopePCT, TotDASqKM, WetlandOrWater, SurficialCoarseC
#Makes barcode looking plot of data records:
#-------------------------------------------
gTile <-
ggplot(siteData,aes(site,year,z=any(c(!is.na(springBP),!is.na(summerBP),!is.na(fallBP)))))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme_bw(base_size=20) +
theme(axis.text.x = element_blank())+
geom_tile()
ggsave( file=paste0(graphsDir, sourceList, '/gTile', sourceList, '.png'), plot=gTile, dpi=dpiIn , width=8,height=5, units='in' )
#Colors by number of observations?
#---------------------------------
gTileHeat <-
ggplot(siteData,aes(site,year,z=count))+
geom_tile(aes(fill=count))+
scale_x_discrete('Site')+
scale_y_continuous('Year')+
theme(axis.text.x = element_blank())
ggsave( file=paste0(graphsDir, sourceList,'/gTileHeat', sourceList, '.png'), plot=gTileHeat, dpi=dpiIn , width=8,height=5, units='in' )
#Define covariates used in model. This gets used later in the prediction stage as well.
fixCov <- c("Latitude","Longitude","Forest", "Agriculture","BasinElevationM","ReachSlopePCNT", "TotDASqKM", "WetlandOrWater","SurficialCoarseC", "ImpoundmentsOpenSqKM", "WetlandsOpenSqKM")
et2 <- et[et$segment %in% 2,]
et3 <- et[et$segment %in% 3,]
cor(et3[,fixCov])
# Segment 2:
#===========
m0S2 <- lm(temp~airTemp+airTempLagged1+airTempLagged2,
data=et2)
m1S2 <- lm(temp~airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
daylS + sradS + sweS,
data=et2)
m2S2 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
daylS + sradS + sweS)^2,
data=et2)
m3S2 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
TNC_DamCount + ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
daylS + sradS + sweS)^2,
data=et2)
AIC(m0S2,m1S2,m2S2,m3S2)
# Segment 3:
#===========
m0S3 <- lm(temp~airTemp+airTempLagged1+airTempLagged2,
data=et3)
m1S3 <- lm(temp~airTemp+airTempLagged1+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
daylS + sradS + sweS,
data=et3)
m2S3 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
daylS + sradS + sweS)^2,
data=et3)
m3S3 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
TNC_DamCount + ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
daylS + sradS + sweS)^2,
data=et3)
AIC(m0S3,m1S3,m2S3,m3S3)
#r3 <- boot.relimp(m2S3)
#Define covariates used in model. This gets used later in the prediction stage as well.
fixCov <- c("Latitude","Longitude","Forest", "Agriculture","BasinElevationM","ReachSlopePCNT", "TotDASqKM", "WetlandOrWater","SurficialCoarseC", "ImpoundmentsOpenSqKM", "WetlandsOpenSqKM")
et2 <- et[et$segment %in% 2,]
et3 <- et[et$segment %in% 3,]
cor(et3[,fixCov])
# Segment 2:
#===========
m0S2 <- lm(temp~airTemp+airTempLagged1+airTempLagged2,
data=et2)
m1S2 <- lm(temp~airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
daylS + sradS + sweS,
data=et2)
m2S2 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
daylS + sradS + sweS)^2,
data=et2)
m3S2 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
TNC_DamCount + ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
daylS + sradS + sweS)^2,
data=et2)
AIC(m0S2,m1S2,m2S2,m3S2)
# Segment 3:
#===========
m0S3 <- lm(temp~airTemp+airTempLagged1+airTempLagged2,
data=et3)
m1S3 <- lm(temp~airTemp+airTempLagged1+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
daylS + sradS + sweS,
data=et3)
m2S3 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
daylS + sradS + sweS)^2,
data=et3)
m3S3 <- lm(temp~(airTemp+airTempLagged1+airTempLagged2+
#segment+
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC+
ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
daylS + sradS + sweS)^2,
data=et3)
AIC(m0S3,m1S3,m2S3,m3S3)
#r3 <- boot.relimp(m2S3)
et2$pred <- predict(m3S2, newdata=et2)
et2$pred0 <- predict(m0S2, newdata=et2)
et3$pred <- predict(m3S3, newdata=et3)
et3$pred0 <- predict(m0S3, newdata=et3)
#all data
gPredObs <-
ggplot(et3,aes(pred,temp))+
geom_point(size=0.5) +
scale_x_continuous(expression(paste("Predicted water temperature (",degree, "C)", sep = "")))+
scale_y_continuous(expression(paste("Observed water temperature (",degree, "C)", sep = "")))+
theme_bw(base_size=20) +
geom_abline(intercept=0,slope=1,color='white')
ggsave( file=paste0(graphsDir, sourceList,'/predObs', sourceList, '.png'), plot=gPredObs, dpi=dpiIn , width=8,height=5, units='in' )
# surrogate for snow model. Get last day in spring where swe is x and first day in fall where swe is x
ggplot(SWERecord[SWERecord$year %in% c(2008,2007,2009),],aes(dOY,swe))+
geom_line(aes(color=site))+
facet_wrap(~year)
# decided to use year as RE in lmer for now. will need to add in more mechanistic model in the future
# try RE model with year as RE
m5bp1 <- lmer(springBP~
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
(1|year),
data=siteData)
anova(m5bp1)
#  BasinElevationM*Latitude+
m6bp1 <- lmer(springBP~
(Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC)^2 +
(1|year),
data=siteData)
m7bp1 <- lmer(springBP~
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
TNC_DamCount + ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
(1|year),
data=siteData)
anova(m7bp1)
AIC(m5bp1,m6bp1,m7bp1)
# not sure why need this [allow.new.levels=T] but throws an error otherwise
#may be because year is in the df
siteData$bp1Pred <- predict(m7bp1,newdata=siteData,allow.new.levels=T)
siteData$bp1PredAvgYear <- predict(m7bp1,newdata=siteData,REform=NA)
# try RE model with year as RE
m5bp1 <- lmer(springBP~
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
(1|year),
data=siteData)
anova(m5bp1)
#  BasinElevationM*Latitude+
m6bp1 <- lmer(springBP~
(Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC)^2 +
(1|year),
data=siteData)
m7bp1 <- lmer(springBP~
Latitude+Longitude+
Forest+ Agriculture+
BasinElevationM+ ReachSlopePCNT+ TotDASqKM+
WetlandOrWater+ SurficialCoarseC +
ImpoundmentsOpenSqKM + WetlandsOpenSqKM +
(1|year),
data=siteData)
anova(m7bp1)
AIC(m5bp1,m6bp1,m7bp1)
# not sure why need this [allow.new.levels=T] but throws an error otherwise
#may be because year is in the df
siteData$bp1Pred <- predict(m7bp1,newdata=siteData,allow.new.levels=T)
siteData$bp1PredAvgYear <- predict(m7bp1,newdata=siteData,REform=NA)
head(et)
head(siteData)
source('~/.active-rstudio-document', echo=TRUE)
